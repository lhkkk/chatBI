# chatBI 项目核心流程图（最终修复版）

```mermaid
graph TD
    %% 基本样式定义
    classDef request fill:#F0F8FF,stroke:#1E90FF,stroke-width:2px
    classDef judge fill:#FFF0F5,stroke:#FF1493,stroke-width:2px
    classDef process fill:#F5FFFA,stroke:#32CD32,stroke-width:2px
    classDef response fill:#FFFACD,stroke:#FFD700,stroke-width:2px
    classDef error fill:#FFE4E1,stroke:#FF6347,stroke-width:2px

    %% 1. 请求接收与解析
    A[接收请求<br>/algorithm/analyze] --> B[解析请求参数
- session_id
- status_code
- user_input
- history_input
- primary_scene
- secondary_scene
- intermediate_result] --> N{status_code?}
    class A,B request
    class N judge

    %% 2. 不同状态码的处理分支
    %% 2.1 新会话/新任务 (100/101)
    N -->|100/101| C[处理新会话/新任务]
    C --> D[闲聊判断]
    D --> E{是闲聊?}
    E -->|是| F[返回闲聊响应<br>状态码:400] --> G[结束]
    E -->|否| H[新任务判断]
    H --> I[一级场景分类
调用PrimarySceneClassification.classify()]
    I --> J{场景匹配?}
    J -->|否| K[返回场景不匹配<br>状态码:202] --> G
    J -->|是| L[调用二级场景判断
get_secondary_scene()]
    class C,D,E,F,H,I,J,K,L process
    class D,E,J judge
    class F,K response

    %% 2.2 一级场景补全 (200)
    N -->|200| D

    %% 2.3 二级场景补全 (201)
    N -->|201| D

    %% 2.4 任务字段补全 (202)
    N -->|202| D

    %% 2.5 字段确认 (203)
    N -->|203| D

    %% 2.6 三级场景补全 (205)
    N -->|205| D

    %% 2.7 用户修改 (204)
    N -->|204| D

    %% 2.8 其他状态码
    N -->|其他| O[返回未知状态码<br>状态码:500] --> G
    class O response

    %% 3. 二级场景分类后的处理
    L --> M{二级场景需要补全?}
    M -->|是| P[返回二级场景补全提示<br>状态码:201] --> G
    M -->|否| Q[调用三级场景判断
ThirdSceneClassifier.classify_third_scene()]
    Q --> R{三级场景需要补全?}
    R -->|是| S[返回三级场景补全提示<br>状态码:205] --> G
    R -->|否| T[调用fill_template_pipeline生成问题]
    T --> U{问题生成成功?}
    U -->|否| V[返回补充提示<br>状态码:202] --> G
    U -->|是| W[调用AttributeExtractor提取属性
AttributeExtractor.extract_attributes()]
    W --> X[构建keywords_info
合并模板字段和属性]
    X --> Y[返回问题生成结果<br>状态码:203] --> G
    class M,P,Q,R,S,T,U,V,W,X,Y process
    class M,R,U judge
    class P,S,V,Y response

    %% 4. 异常处理
    N -.->|异常| Z[捕获异常<br>记录错误日志] --> AA[返回处理失败<br>状态码:500] --> G
    class Z,AA error

    %% 5. 辅助流程
    L -.->|调用| BA[调用NLP服务获取tokens]
    BA -.->|调用| BB[调用add_ip_to_tokens添加IP到tokens]
    BB -.->|调用| BC[调用SceneClassifier.classify进行二级场景分类]
    BC -.->|返回| L

    %% 6. 状态码流转图
    subgraph 状态码流转
        SS[新会话/新任务<br>100/101] --> S1[一级场景分类]
        SS --> S2[一级场景补全<br>200]
        SS --> S3[二级场景补全<br>201]
        SS --> S4[任务字段补全<br>202]
        SS --> S5[字段确认<br>203]
        SS --> S6[三级场景补全<br>205]
        SS --> S7[用户修改<br>204]

        S1 --> S8[二级场景分类]
        S2 --> S8
        S3 --> S8
        S4 --> S9[三级场景分类]
        S8 --> S9
        S9 --> S10[三级场景补全<br>205]
        S9 --> S11[问题生成]
        S10 --> S11
        S11 --> S12[任务字段补全<br>202]
        S11 --> S13[字段确认<br>203]
        S12 --> S13
        S13 --> S14[用户修改<br>204]
        S14 --> S11
    end
    class SS,S1,S2,S3,S4,S5,S6,S7,S8,S9,S10,S11,S12,S13,S14 process

    %% 7. 一级场景分类后的处理（针对不同状态码）
    I -.->|status_code=100/101| L
    I -.->|status_code=200| L
    I -.->|status_code=201| L
    I -.->|status_code=202| L
    I -.->|status_code=203| L
    I -.->|status_code=205| L
    I -.->|status_code=204| L
```

# chatBI 项目核心流程说明

## 1. 请求接收与解析

- 通过`/algorithm/analyze`接口接收 POST 请求
- 解析请求参数：session_id、status_code、user_input、history_input、primary_scene、secondary_scene、intermediate_result 等

## 2. 不同状态码的处理分支

### 2.1 新会话/新任务 (100/101)

1. **闲聊判断**：调用大模型判断用户输入是否为闲聊
2. **新任务判断**：调用大模型判断用户输入是否为新任务
3. **一级场景分类**：调用`PrimarySceneClassification.classify()`进行一级场景分类
4. **场景匹配判断**：比较分类结果与预期场景是否匹配
5. **二级场景判断**：调用`get_secondary_scene()`进行二级场景分类

### 2.2 一级场景补全 (200)

- 直接进入闲聊判断流程，然后进行一级场景分类

### 2.3 二级场景补全 (201)

- 直接进入闲聊判断流程，然后进行一级场景分类

### 2.4 任务字段补全 (202)

- 直接进入闲聊判断流程，然后进行一级场景分类

### 2.5 字段确认 (203)

- 直接进入闲聊判断流程，然后进行一级场景分类

### 2.6 三级场景补全 (205)

- 直接进入闲聊判断流程，然后进行一级场景分类

### 2.7 用户修改 (204)

- 直接进入闲聊判断流程，然后进行一级场景分类

## 3. 二级场景分类后的处理

1. **二级场景补全判断**：如果二级场景需要补全，返回状态码 201
2. **三级场景分类**：调用`ThirdSceneClassifier.classify_third_scene()`进行三级场景分类
3. **三级场景补全判断**：如果三级场景需要补全，返回状态码 205
4. **问题生成**：调用`fill_template_pipeline()`生成问题
5. **属性提取**：调用`AttributeExtractor.extract_attributes()`提取属性
6. **构建 keywords_info**：合并模板字段和属性
7. **返回问题生成结果**：返回状态码 203

## 4. 异常处理

- 捕获处理过程中的所有异常
- 详细记录异常信息
- 返回状态码 500，提示处理失败

## 5. 辅助流程

- **调用 NLP 服务获取 tokens**：调用外部 NLP 服务进行 token 提取
- **调用 add_ip_to_tokens 添加 IP 到 tokens**：确保 IP 地址被包含在 tokens 中
- **调用 SceneClassifier.classify 进行二级场景分类**：进行二级场景分类

## 6. 状态码流转

```
新会话/新任务 (100/101)
    ├─> 一级场景分类
    ├─> 一级场景补全 (200)
    ├─> 二级场景补全 (201)
    ├─> 任务字段补全 (202)
    ├─> 字段确认 (203)
    ├─> 三级场景补全 (205)
    └─> 用户修改 (204)
        └─> 闲聊判断
            └─> 新任务判断
                └─> 一级场景分类
                    └─> 场景匹配判断
                        └─> 二级场景分类
                            ├─> 二级场景补全 (201)
                            └─> 三级场景分类
                                ├─> 三级场景补全 (205)
                                └─> 问题生成
                                    ├─> 任务字段补全 (202)
                                    └─> 字段确认 (203)
                                        └─> 用户修改 (204)
```

# 状态码说明

| 状态码 | 含义         | 处理逻辑                         |
| ------ | ------------ | -------------------------------- |
| 100    | 新会话       | 初始化会话数据，开始新任务       |
| 101    | 新任务       | 开始新任务，清除旧任务数据       |
| 200    | 一级场景补全 | 一级场景已补全，进入二级场景分类 |
| 201    | 二级场景补全 | 二级场景已补全，进入三级场景分类 |
| 202    | 任务字段补全 | 任务字段已补全，生成问题         |
| 203    | 字段确认     | 字段已确认，返回最终结果         |
| 204    | 用户修改     | 用户修改了问题，重新生成问题     |
| 205    | 三级场景补全 | 三级场景已补全，生成问题         |
| 400    | 闲聊         | 直接回复，不进入流量分析流程     |
| 500    | 处理失败     | 处理过程中发生错误，返回错误信息 |

# 核心组件调用

| 组件                       | 方法                                                                    | 功能              | 文件位置                                      |
| -------------------------- | ----------------------------------------------------------------------- | ----------------- | --------------------------------------------- |
| PrimarySceneClassification | classify(user_input, history_chat)                                      | 一级场景分类      | service/primary_scene_classification.py       |
| SceneClassifier            | classify(user_input, history, tokens)                                   | 二级场景分类      | service/scene_classification_service.py       |
| ThirdSceneClassifier       | classify_third_scene(second_scene, user_input, history, tokens, fields) | 三级场景分类      | service/third_scene_classification_service.py |
| AttributeExtractor         | extract_attributes(query, history)                                      | 属性提取          | service/attribute_extraction_service.py       |
| fill_template_pipeline     | -                                                                       | 问题生成          | service/fill_template_pipeline_service.py     |
| add_ip_to_tokens           | add_ip_to_tokens(user_input, tokens)                                    | 添加 IP 到 tokens | utils/ip_utils.py                             |

# 技术亮点

1. **多轮对话机制**：通过状态码驱动的多轮对话，逐步澄清用户需求
2. **大模型应用**：使用大模型进行闲聊判断、新任务判断、场景分类等
3. **NLP 服务集成**：调用外部 NLP 服务进行 token 提取
4. **属性提取算法**：基于正则表达式和关键词匹配提取属性
5. **模板生成机制**：使用模板生成可执行的查询问题
6. **完善的异常处理**：确保系统稳定性
7. **详细的日志记录**：便于调试和监控

# 业务流程

1. **用户输入**：用户通过前端输入流量分析请求
2. **一级场景分类**：系统判断请求属于哪种一级场景
3. **二级场景分类**：系统判断请求属于哪种二级场景
4. **三级场景分类**：系统判断请求属于哪种三级场景
5. **属性提取**：系统从用户输入中提取各种属性
6. **问题生成**：系统生成可执行的查询问题
7. **用户确认**：系统返回问题给用户确认
8. **执行查询**：用户确认后，系统执行查询
9. **返回结果**：系统将查询结果返回给用户

# 代码结构

```
chatBI-1.0.0-develop/
├── main.py              # 算法服务入口
├── service/
│   ├── primary_scene_classification.py      # 一级场景分类
│   ├── scene_classification_service.py      # 二级场景分类
│   ├── third_scene_classification_service.py # 三级场景分类
│   ├── attribute_extraction_service.py       # 属性提取
│   └── fill_template_pipeline_service.py     # 问题生成
├── utils/
│   └── ip_utils.py                          # IP工具
├── config/                                   # 配置文件
├── models/                                   # 模型定义
└── prompts/                                  # 提示词模板
```

# 性能优化

1. **缓存机制**：对频繁使用的结果进行缓存
2. **异步处理**：对耗时操作进行异步处理
3. **并行调用**：并行调用多个服务，提高处理速度
4. **优化大模型调用**：合理设置大模型参数，减少调用次数
5. **优化算法**：优化各种算法，提高处理效率

# 安全性

1. **输入验证**：对所有输入进行严格验证
2. **输出过滤**：对所有输出进行过滤，防止 XSS 攻击
3. **身份验证**：对 API 调用进行身份验证
4. **授权控制**：对不同用户设置不同的权限
5. **日志审计**：详细记录所有操作，便于审计

# 扩展性设计

1. **场景扩展**：可以轻松添加新的场景类型
2. **属性扩展**：可以轻松添加新的属性类型
3. **模板扩展**：可以轻松添加新的问题模板
4. **大模型扩展**：可以切换到其他大模型服务
5. **NLP 服务扩展**：可以切换到其他 NLP 
- 分类方法: 基于规则+大模型
- 分类维度: 业务类型/数据类型/分析目标
- 分类结果: 一级场景标签] --> OL2[二级场景分类器
- 分类方法: 基于NLP+规则
- 分类维度: 具体业务场景
- 分类结果: 二级场景标签
- 依赖: tokens, 一级场景] --> OL3[三级场景分类器
- 分类方法: 基于模板+规则
- 分类维度: 具体分析类型
- 分类结果: 三级场景标签
- 依赖: 二级场景, 字段信息] --> OL4[问题生成器
- 生成方法: 基于模板填充
- 生成结果: 结构化问题模板
- 依赖: 三级场景, 用户输入] --> OL5[属性提取器
- 提取方法: 基于规则+ML
- 提取结果: 实体属性列表
- 依赖: 生成的问题, 历史对话] 
    end
    Z -.->|使用| OL1
    AC -.->|使用| OL2
    AF -.->|使用| OL3
    AK -.->|使用| OL4
    AN -.->|使用| OL5
    class OL1,OL2,OL3,OL4,OL5 process
```

# chatBI项目完整意图识别流程说明

## 1. 请求接收与初始化

### 1.1 请求接收
- **接口**: `/algorithm/analyze`
- **方法**: POST
- **输入**: 完整HTTP请求
- **输出**: 请求对象

### 1.2 参数解析与验证
- **输入**: HTTP请求
- **输出**: 验证后的请求参数
- **处理逻辑**:
  1. 解析请求体中的JSON数据
  2. 验证必填字段是否存在:
     - session_id: 会话标识
     - status_code: 当前会话状态
     - user_input: 用户当前输入
     - history_input: 历史对话
  3. 验证参数数据类型
  4. 格式化输入数据

### 1.3 会话状态初始化
- **输入**: session_id, status_code
- **输出**: 会话上下文对象
- **处理逻辑**:
  1. 根据session_id查找现有会话
  2. 如果会话不存在，创建新会话
  3. 加载会话历史和中间状态
  4. 设置当前状态码
  5. 初始化上下文对象

## 2. 上下文管理与初步判断

### 2.1 上下文管理模块初始化
- **输入**: 会话上下文对象
- **输出**: 上下文管理实例
- **处理逻辑**:
  1. 加载场景知识库
  2. 加载实体属性库
  3. 初始化历史对话处理器
  4. 配置相似度算法
  5. 初始化上下文管理实例

### 2.2 闲聊判断
- **输入**: user_input, 历史对话
- **输出**: 闲聊判断结果 (是/否)
- **处理逻辑**:
  1. 调用大模型
  2. 使用闲聊分类prompt
  3. 解析大模型返回结果
  4. 输出判断结果

### 2.3 历史对话分析
- **输入**: history_input
- **输出**: 历史对话特征向量, 过往实体列表, 历史场景序列
- **处理逻辑**:
  1. 对历史对话进行分词处理
  2. 将历史对话向量化
  3. 提取历史对话中的实体
  4. 构建历史场景序列

### 2.4 当前问题分析
- **输入**: user_input
- **输出**: 当前问题特征向量, 当前实体列表, 问题类型
- **处理逻辑**:
  1. 对当前问题进行分词处理
  2. 将当前问题向量化
  3. 提取当前问题中的实体
  4. 判断问题类型

### 2.5 上下文相似度计算
- **输入**: 历史对话特征向量, 当前问题特征向量, 过往实体列表, 当前实体列表
- **输出**: 上下文相似度分数, 匹配的历史场景
- **处理逻辑**:
  1. 计算历史对话与当前问题的文本相似度
  2. 计算历史实体与当前实体的匹配度
  3. 加权融合相似度分数
  4. 查找匹配的历史场景

### 2.6 相似度阈值判断
- **输入**: 上下文相似度分数
- **输出**: 匹配结果 (是/否)
- **处理逻辑**:
  1. 比较相似度分数与预设阈值
  2. 输出匹配结果

## 3. 上下文匹配成功处理

### 3.1 历史场景验证
- **输入**: 匹配的历史场景, 当前问题
- **输出**: 验证后的场景类型
- **处理逻辑**:
  1. 检查历史场景与当前问题的相关性
  2. 验证场景的有效性
  3. 输出验证后的场景类型

### 3.2 确认场景级别
- **输入**: 验证后的场景类型
- **输出**: 一级/二级/三级场景
- **处理逻辑**:
  1. 根据场景定义确定场景级别
  2. 输出场景级别

## 4. 上下文匹配失败处理 - Semantic Router

### 4.1 Semantic Router初始化
- **输入**: 会话上下文, 配置文件
- **输出**: Semantic Router实例
- **处理逻辑**:
  1. 加载槽位定义
  2. 配置匹配算法
  3. 初始化路由规则
  4. 创建Semantic Router实例

### 4.2 当前问题槽位提取
- **输入**: user_input, 当前实体列表
- **输出**: 当前槽位字典
- **处理逻辑**:
  1. 提取实体类型槽
  2. 提取属性槽
  3. 提取操作槽
  4. 提取时间槽
  5. 构建当前槽位字典

### 4.3 历史对话槽位提取
- **输入**: history_input, 过往实体列表
- **输出**: 历史槽位字典列表
- **处理逻辑**:
  1. 遍历历史对话
  2. 从每条对话中提取槽位
  3. 构建历史槽位字典列表

### 4.4 槽位相似度比对
- **输入**: 当前槽位字典, 历史槽位字典列表, 槽位权重配置
- **输出**: 最佳匹配槽位组合, 匹配分数
- **处理逻辑**:
  1. 对每个历史槽位字典进行相似度计算
  2. 逐槽位计算相似度
  3. 应用槽位权重
  4. 计算总匹配分数
  5. 选择最佳匹配槽位组合

### 4.5 槽位匹配阈值判断
- **输入**: 匹配分数
- **输出**: 匹配结果 (是/否)
- **处理逻辑**:
  1. 比较匹配分数与预设阈值
  2. 输出匹配结果

### 4.6 场景映射
- **输入**: 最佳匹配槽位组合, 场景-槽位映射规则
- **输出**: 匹配的场景类型
- **处理逻辑**:
  1. 根据槽位组合查找对应的场景定义
  2. 输出匹配的场景类型

### 4.7 场景级别确定
- **输入**: 匹配的场景类型
- **输出**: 一级/二级/三级场景
- **处理逻辑**:
  1. 根据场景定义确定场景级别
  2. 输出场景级别

## 5. 原有逻辑场景判断

### 5.1 新任务判断
- **输入**: user_input, 历史对话
- **输出**: 新任务判断结果 (是/否)
- **处理逻辑**:
  1. 调用大模型
  2. 使用新任务分类prompt
  3. 解析大模型返回结果
  4. 输出判断结果

### 5.2 一级场景分类
- **输入**: user_input, history_chat
- **输出**: 一级场景分类结果
- **处理逻辑**:
  1. 调用`PrimarySceneClassification.classify()`
  2. 输入用户输入和历史对话
  3. 返回一级场景

### 5.3 一级场景匹配判断
- **输入**: 一级场景分类结果
- **输出**: 匹配结果 (是/否)
- **处理逻辑**:
  1. 检查一级场景是否有效
  2. 输出匹配结果

### 5.4 二级场景分类准备
- **输入**: user_input, history, 一级场景
- **输出**: 处理后的输入数据
- **处理逻辑**:
  1. 调用NLP服务获取tokens
  2. 调用`add_ip_to_tokens`添加IP到tokens

### 5.5 二级场景分类
- **输入**: user_input, history, tokens
- **输出**: 二级场景分类结果
- **处理逻辑**:
  1. 调用`SceneClassifier.classify()`
  2. 输入用户输入、历史和tokens
  3. 返回二级场景

### 5.6 二级场景匹配判断
- **输入**: 二级场景分类结果
- **输出**: 匹配结果 (是/否)
- **处理逻辑**:
  1. 检查二级场景是否有效
  2. 输出匹配结果

### 5.7 三级场景分类
- **输入**: second_scene, user_input, history, tokens, fields
- **输出**: 三级场景分类结果
- **处理逻辑**:
  1. 调用`ThirdSceneClassifier.classify_third_scene()`
  2. 输入二级场景、用户输入、历史、tokens和字段
  3. 返回三级场景

### 5.8 三级场景匹配判断
- **输入**: 三级场景分类结果
- **输出**: 匹配结果 (是/否)
- **处理逻辑**:
  1. 检查三级场景是否有效
  2. 输出匹配结果

### 5.9 场景信息整合
- **输入**: 一级场景, 二级场景, 三级场景
- **输出**: 完整场景信息
- **处理逻辑**:
  1. 合并场景信息
  2. 验证场景完整性
  3. 输出完整场景信息

## 6. 统一场景处理

### 6.1 问题生成
- **输入**: 完整场景信息, user_input, history
- **输出**: 生成的问题模板, 缺失字段
- **处理逻辑**:
  1. 调用`fill_template_pipeline()`
  2. 输入场景信息和用户输入
  3. 返回问题模板和缺失字段

### 6.2 问题生成成功判断
- **输入**: 生成的问题模板, 缺失字段
- **输出**: 生成结果 (是/否)
- **处理逻辑**:
  1. 检查问题模板是否有效
  2. 检查缺失字段是否可以处理
  3. 输出生成结果

### 6.3 属性提取
- **输入**: 生成的问题, history
- **输出**: 提取的属性列表
- **处理逻辑**:
  1. 调用`AttributeExtractor.extract_attributes()`
  2. 输入问题和历史
  3. 返回提取的属性

### 6.4 构建keywords_info
- **输入**: 问题模板, 缺失字段, 提取的属性
- **输出**: keywords_info字典
- **处理逻辑**:
  1. 合并模板字段和提取的属性
  2. 构建完整的keywords_info
  3. 验证keywords_info完整性

## 7. 错误处理与异常管理

### 7.1 异常捕获与分类
- **输入**: 异常对象
- **输出**: 错误类型, 错误信息
- **处理逻辑**:
  1. 捕获异常
  2. 分类错误类型
  3. 提取错误信息
  4. 输出错误类型和信息

### 7.2 错误日志记录
- **输入**: 错误类型, 错误信息, 会话ID
- **输出**: 日志记录结果
- **处理逻辑**:
  1. 记录详细错误信息到日志系统
  2. 包括错误类型、错误信息、会话ID、时间戳等
  3. 输出日志记录结果

### 7.3 错误响应生成
- **输入**: 错误类型, 错误信息
- **输出**: HTTP响应
- **处理逻辑**:
  1. 生成友好的错误提示
  2. 构造HTTP响应对象
  3. 设置状态码为500
  4. 输出HTTP响应

## 8. 状态管理与状态码流转

### 8.1 状态码定义
- **100**: 新会话 - 初始化会话数据，开始新任务
- **101**: 新任务 - 开始新任务，清除旧任务数据
- **200**: 一级场景补全 - 一级场景已补全，进入二级场景分类
- **201**: 二级场景补全 - 二级场景已补全，进入三级场景分类
- **202**: 任务字段补全 - 任务字段已补全，生成问题
- **203**: 字段确认 - 字段已确认，返回最终结果
- **204**: 用户修改 - 用户修改了问题，重新生成问题
- **205**: 三级场景补全 - 三级场景已补全，生成问题
- **400**: 闲聊 - 直接回复，不进入流量分析流程
- **500**: 处理失败 - 处理过程中发生错误，返回错误信息

### 8.2 状态转换规则
- 100/101 → 200/201/202/203/205
- 200 → 201/202/203/205
- 201 → 202/203/205
- 202 → 203
- 203 → 204
- 204 → 202/203
- 205 → 202/203

### 8.3 会话状态存储
- **session_id**: 会话唯一标识
- **current_state**: 当前状态码
- **scene_info**: 场景信息（一级、二级、三级）
- **intermediate_result**: 中间处理结果
- **history**: 历史对话记录
- **timeout**: 会话超时时间

### 8.4 状态验证与恢复
- 验证当前状态的合法性
- 处理会话超时情况
- 恢复中断的会话

## 9. 核心组件说明

### 9.1 Semantic Router核心组件
1. **槽位定义配置**: 定义各种槽位类型和权重
2. **槽位提取器**: 从用户输入中提取槽位信息
3. **槽位相似度计算器**: 计算槽位之间的相似度
4. **场景映射规则**: 将槽位组合映射到具体场景
5. **路由决策器**: 根据匹配结果选择最佳场景

### 9.2 上下文管理核心组件
1. **知识库管理**: 管理场景知识库、实体属性库和历史对话库
2. **相似度计算引擎**: 计算文本、实体和上下文相似度
3. **历史对话处理器**: 处理和分析历史对话
4. **场景推荐器**: 根据历史和上下文推荐场景

### 9.3 原有逻辑核心组件
1. **一级场景分类器**: 进行一级场景分类
2. **二级场景分类器**: 进行二级场景分类
3. **三级场景分类器**: 进行三级场景分类
4. **问题生成器**: 生成结构化问题模板
5. **属性提取器**: 提取实体属性

## 10. 完整业务流程

```
接收请求 → 参数解析与验证 → 会话状态初始化 → 上下文管理模块初始化 → 闲聊判断
  ├─> 是闲聊 → 返回闲聊响应 (400)
  └─> 否闲聊 → 历史对话分析 → 当前问题分析 → 上下文相似度计算
      ├─> 相似度 ≥ 阈值 → 历史场景验证 → 确认场景级别 → 统一场景处理
      └─> 相似度 < 阈值 → Semantic Router初始化 → 当前问题槽位提取 → 历史对话槽位提取 → 槽位相似度比对
          ├─> 匹配分数 ≥ 阈值 → 场景映射 → 场景级别确定 → 统一场景处理
          └─> 匹配分数 < 阈值 → 新任务判断 → 一级场景分类
              ├─> 一级场景不匹配 → 返回场景不匹配 (202)
              └─> 一级场景匹配 → 二级场景分类准备 → 二级场景分类
                  ├─> 二级场景不匹配 → 返回二级场景补全 (201)
                  └─> 二级场景匹配 → 三级场景分类
                      ├─> 三级场景不匹配 → 返回三级场景补全 (205)
                      └─> 三级场景匹配 → 场景信息整合 → 统一场景处理
                          ├─> 问题生成失败 → 返回字段补全 (202)
                          └─> 问题生成成功 → 属性提取 → 构建keywords_info → 返回字段确认 (203)
```

## 11. 扩展性设计

1. **槽位扩展**: 可以轻松添加新的槽位类型
2. **场景扩展**: 可以轻松添加新的场景类型
3. **算法扩展**: 可以替换或优化相似度计算算法
4. **知识库扩展**: 可以扩展知识库内容
5. **模型扩展**: 可以集成更先进的NLP模型
6. **组件扩展**: 可以添加新的处理组件

## 12. 性能优化

1. **缓存机制**: 缓存频繁使用的知识库和槽位定义
2. **异步处理**: 对耗时操作进行异步处理
3. **并行计算**: 并行计算相似度和槽位提取
4. **索引优化**: 优化知识库索引，提高查询速度
5. **资源池化**: 池化大模型和NLP服务调用

## 13. 可执行性保障

1. **明确的输入输出**: 每个步骤都有明确的输入和输出
2. **具体的处理逻辑**: 每个步骤都有详细的处理逻辑
3. **可配置的参数**: 关键参数可配置，便于调整
4. **完善的错误处理**: 每个步骤都有错误处理机制
5. **清晰的状态管理**: 状态流转清晰，易于跟踪
6. **模块化设计**: 组件化设计，便于维护和扩展

# 总结

本流程图提供了一个全面、详细、可执行的chatBI项目意图识别方案，结合了上下文管理、Semantic Router和原有逻辑，确保了意图识别的准确性和可靠性。每个步骤都有明确的输入、输出和处理逻辑，便于实现和维护。流程图采用了模块化设计，具有良好的扩展性和性能优化空间，可以根据